<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="icon" href="static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="static/styles/main.css">
    <title>Three.JS-Webpack Boilerplate</title>
  </head>
  <body>
    <script type="x-shader/x-vertex" id="physicsVertexShader">
      attribute vec2 reference;
      
      uniform sampler2D texturePosition;
      uniform float scale;
      //#include <fog_pars_vertex>

      varying vec4 vColor;

      void main(){
          //#include <begin_vertex>
          //#include <project_vertex>
          
          //vec4 tmpPos = scale * texture2D(texturePosition,reference);
          vec4 tmpPos = texture2D(texturePosition,reference);

          float tmpX = scale * tmpPos.x;
          float tmpY = scale * tmpPos.y;
          float tmpZ = scale * tmpPos.z;

          float rho = tmpPos.a;

          //float rho = min( (tmpPos.a - 3.0)/3.0, 1.0 );

          vColor = vec4(0.0,1.0,1.0,1.0);

          float r = (tmpX / scale) + 0.5;
          float g = (tmpY / scale) + 0.5;
          float b = (tmpZ / scale) + 0.5;
          //vColor = vec4(r,g,b,rho);
          //vColor = vec4(rho,rho,rho,1.0);
          
          gl_Position=projectionMatrix * modelViewMatrix * vec4(tmpX,tmpY,tmpZ,1.0);
          
          gl_PointSize=3.0;
          
          //#include <fog_vertex>

      }
    </script>
    <script type="x-shader/x-fragment" id="pointFragmentShader">
        //#include <fog_pars_fragment>
        varying vec4 vColor;
        void main(){
            gl_FragColor=vColor;
            //#include <fog_fragment>
        }
    </script>


    <script type="x-shader/x-fragment" id="fragmentShaderAcceleration">
      uniform float equationOfStateConst;
      uniform float polytropicIndex;
      uniform float smoothingLength;
      uniform float particleMass;
      uniform float lambda;
      uniform float viscosity;

      const float PI = 3.141592653589793;

      const float width = resolution.x;
			const float height = resolution.y;

      float shift_right (float v, float amt) { 
        v = floor(v) + 0.5; 
        return floor(v / exp2(amt)); 
      }
      float shift_left (float v, float amt) { 
          return floor(v * exp2(amt) + 0.5); 
      }
      float mask_last (float v, float bits) { 
          return mod(v, shift_left(1.0, bits)); 
      }
      float extract_bits (float num, float from, float to) { 
          from = floor(from + 0.5); to = floor(to + 0.5); 
          return mask_last(shift_right(num, from), to - from); 
      }

      vec4 encode_float (float val) { 
        if (val == 0.0) return vec4(0, 0, 0, 0); 
        float sign = val > 0.0 ? 0.0 : 1.0; 
        val = abs(val); 
        float exponent = floor(log2(val)); 
        float biased_exponent = exponent + 127.0; 
        float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; 
        float t = biased_exponent / 2.0; 
        float last_bit_of_biased_exponent = fract(t) * 2.0; 
        float remaining_bits_of_biased_exponent = floor(t); 
        float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; 
        float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; 
        float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; 
        float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; 
        return vec4(byte4, byte3, byte2, byte1); 
      }

      vec3 evaluateKernelDerivative(float xDist, float yDist, float zDist){
        float r = sqrt(xDist*xDist + yDist*yDist + zDist*zDist);

        float n = -2.0 * exp(-(r * r) / (smoothingLength * smoothingLength));
        n /= pow(smoothingLength,5.0);
        n /= pow(PI, (3.0/2.0) );

        return vec3(n * xDist, n * yDist, n * zDist);
      }

      float evaluatePressure(float rho){
        return equationOfStateConst * pow(rho, 1.0 + (1.0 / polytropicIndex) );
      }

      void main(){
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec4 tmpPos = texture2D( texturePosition, uv);
        vec4 tmpVel = texture2D( textureVelocity, uv);
        vec4 tmpRho = texture2D( textureDensity, uv);

        float rho = tmpRho.x;
        float pressure = evaluatePressure(rho);

        float selfXPos = tmpPos.x;
        float selfYPos = tmpPos.y;
        float selfZPos = tmpPos.z;

        vec4 otherPosition;
        vec3 gradient;
        float otherPressure;

        float ax=0.0;
        float ay=0.0;
        float az=0.0;

        for (float y = 0.0; y < height; y++){
          for (float x = 0.0; x < width; x++){
            vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;

            otherPosition = texture2D(texturePosition, ref);
            float otherRho = texture2D(textureDensity, ref).x;
            float otherPressure = evaluatePressure(otherRho);

            float xDist = otherPosition.x - selfXPos;
            float yDist = otherPosition.y - selfYPos;
            float zDist = otherPosition.z - selfZPos;

            gradient = evaluateKernelDerivative(xDist,yDist,zDist);

            /*ax += particleMass * 2.0 * (pressure/(rho*rho)) * gradient.x;
            ay += particleMass * 2.0 * (pressure/(rho*rho)) * gradient.y;
            az += particleMass * 2.0 * (pressure/(rho*rho)) * gradient.z;*/

            float pressureAcc =  (pressure/(rho*rho)) + (otherPressure/(otherRho*otherRho));

            ax += particleMass * pressureAcc * gradient.x;
            ay += particleMass * pressureAcc * gradient.y;
            az += particleMass * pressureAcc * gradient.z;
          }
        }

        ax = -ax - lambda * selfXPos;// - viscosity * tmpVel.x;
        ay = -ay - lambda * selfYPos;// - viscosity * tmpVel.y;
        az = -az - lambda * selfZPos;// - viscosity * tmpVel.z;


        gl_FragColor = vec4(ax,ay,az,1.0);

        //gl_FragColor = vec4(0.0,-0.3,0.0,1.0);

        //gl_FragColor = encode_float(-0.3);
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShaderVelocity">  
      uniform float deltaT;

      void main(){
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec4 tmpAcc = texture2D( textureAcceleration, uv );
        vec4 tmpVel = texture2D( textureVelocity, uv);

        float xVel = tmpVel.x + tmpAcc.x * 0.5 * deltaT;
        float yVel = tmpVel.y + tmpAcc.y * 0.5 * deltaT;
        float zVel = tmpVel.z + tmpAcc.z * 0.5 * deltaT;

        gl_FragColor = vec4(xVel,yVel,zVel,1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShaderPosition">  
      uniform float deltaT;
      //uniform float smoothingLength;
      //uniform float particleMass;

      //const float PI = 3.141592653589793;

      /*float evaluateKernel(float xDist, float yDist, float zDist){
        float r = sqrt(xDist*xDist + yDist*yDist + zDist*zDist);

        float w = (1.0 / (smoothingLength * sqrt(PI)));
        w = w * w * w * exp( -(r*r) / (smoothingLength*smoothingLength));

        return w;
      }*/

      void main(){
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec4 tmpVel = texture2D( textureVelocity, uv);
        vec4 tmpPos = texture2D( texturePosition, uv);

        float selfXPos = tmpPos.x + tmpVel.x * deltaT;
        float selfYPos = tmpPos.y + tmpVel.y * deltaT;
        float selfZPos = tmpPos.z + tmpVel.z * deltaT;

        //compute particle density from all positions
        
        /*vec3 otherPosition;

        float rho = 0.0;

        for (float y = 0.0; y < height; y++){
          for (float x = 0.0; x < width; x++){
            vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;

            otherPosition = texture2D(texturePosition, ref).xyz;

            float xDist = otherPosition.x - selfXPos;
            float yDist = otherPosition.y - selfYPos;
            float zDist = otherPosition.z - selfZPos;

            rho += particleMass * evaluateKernel(xDist, yDist, zDist);
          }
        }
        */

        gl_FragColor = vec4(selfXPos,selfYPos,selfZPos,0.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShaderDensity">
      uniform float smoothingLength;
      uniform float particleMass;

      const float PI = 3.141592653589793;

      const float width = resolution.x;
			const float height = resolution.y;

      float evaluateKernel(float xDist, float yDist, float zDist){
        float r = sqrt(xDist*xDist + yDist*yDist + zDist*zDist);

        float w = (1.0 / (smoothingLength * sqrt(PI)));
        w = w * w * w * exp( -(r*r) / (smoothingLength*smoothingLength));

        return w;
      }

      void main(){
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec4 selfPos = texture2D( texturePosition, uv);

        vec3 otherPosition;

        float rho = 0.0;

        for (float y = 0.0; y < height; y++){
          for (float x = 0.0; x < width; x++){
            vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;

            otherPosition = texture2D(texturePosition, ref).xyz;

            float xDist = otherPosition.x - selfPos.x;
            float yDist = otherPosition.y - selfPos.y;
            float zDist = otherPosition.z - selfPos.z;

            rho += particleMass * evaluateKernel(xDist, yDist, zDist);
          }
        }

        gl_FragColor = vec4(rho,0.0,0.0,0.0);
      }

    </script>

    <!-- Information modal -->
    <!--a id="open-modal-btn" class="float">
      <i class="icon-float material-icons">menu</i>
    </a>
    <div id="info-modal" class="modal">
      <div class="modal-content">
        <span class="close-modal-btn">&times;</span>
        <h3>Welcome to my Three.JS-Webpack boilerplate!</h3>
        <p>It is a great and easy way to bootstrap Three.Js project.</p>
        <p>To get started clone the repo <code>git clone https://github.com/aakatev/three-js-webpack.git</code>.</p>
        <p>For more information, navigate to the <a href="https://github.com/aakatev/three-js-webpack">project GitHub page</a>!</p>
      </div>
    </div-->
    <!-- End information modal -->

    <script src="public/bundle.js"></script>
  </body>
</html>
