import * as THREE from 'three'
import { WEBGL } from './webgl'
//import './modal'
import { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer'

if (WEBGL.isWebGLAvailable()) {
  var camera, scene, renderer, gpuCompute;

  var textureDim = 64;
  var nParticles = textureDim * textureDim;

  init();

  gpuCompute = new GPUComputationRenderer(textureDim,textureDim,renderer);
  var error = gpuCompute.init();
  if ( error !== null ) {
    console.error( error );
  }

  render();

  function init() {
    camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      5,
      3500
    );

    camera.position.z = 2750;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

    var geometry = new THREE.BufferGeometry();
    var positions = [];
    var n2 = 500;//nPoints / 2;

    for ( var i = 0; i < nParticles; i ++ ) {

      // positions

      var x = Math.random() * 1000 - n2;
      var y = Math.random() * 1000 - n2;
      var z = Math.random() * 1000 - n2;

      positions.push( x, y, z );
    }

    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );

    var material = new THREE.ShaderMaterial({
      uniforms: THREE.UniformsUtils.merge( [
        THREE.UniformsLib[ 'fog' ]
      ] ),
      vertexShader: document.getElementById('physicsVertexShader').textContent,
      fragmentShader: document.getElementById('pointFragmentShader').textContent,
      vertexColors: true,
      fog: true
    });

    var points = new THREE.Points( geometry, material );
    scene.add( points );

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', onWindowResize, false);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function render() {
    renderer.render(scene, camera);
  }
} else {
  var warning = WEBGL.getWebGLErrorMessage();
  document.body.appendChild(warning);
}
